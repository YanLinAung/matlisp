(in-package :matlisp)

(defgeneric norm (vec &optional n))
(define-tensor-method norm ((vec numeric-tensor :input) &optional (n 2))
  `(cond
     ((typep n 'real)
      (let-typed ((sum (t/fid+ ,(field-type (cl vec))) :type ,(field-type (cl vec))))
	(dorefs (idx (dimensions vec))
		((ref vec :type ,(cl vec)))
	  (setf sum (t/f+ ,(field-type (cl vec)) sum (expt (abs ref) n))))
	(expt sum (/ n))))
     ((eql n :sup)
      (tensor-foldl ,(cl vec) max vec (t/fid+ ,(field-type (cl vec))) :key abs))))

;;It's fairly simple to write optimized versions. Optimize at your own discretion.
;; (defun tomax (vec)
;;   (declare (type real-tensor vec))
;;   (let-typed ((max 0d0 :type double-float))	     
;; 	     (very-quickly
;; 	       (dorefs (idx (dimensions vec))
;; 		       ((rvec vec  :type real-tensor))
;; 		 (let-typed ((r rvec :type double-float))
;; 		   (when (> r max)
;; 		     (setf max r)))))
;; 	     max))
(defgeneric tensor-max (vec &optional key))
(define-tensor-method tensor-max ((vec standard-tensor :input) &optional (key #'id))
  `(let* ((max-idx (make-list (order vec) :initial-element 0))
	  (max (funcall key (ref vec max-idx))))
     (dorefs (idx (dimensions vec))
	     ((ref vec :type ,(cl vec)))
       (let ((kval (funcall key ref)))
	 (when (> kval max)
	   (setf max kval)
	   (lvec->list! idx max-idx))))
     (values max max-idx)))

(defgeneric tensor-min (vec &optional key))
(define-tensor-method tensor-min ((vec standard-tensor :input) &optional (key #'id))
  `(let* ((min-idx (make-list (order vec) :initial-element 0))
	  (min (funcall key (ref vec min-idx))))
     (dorefs (idx (dimensions vec))
	     ((ref vec :type ,(cl vec)))
       (let ((kval (funcall key ref)))
	 (when (< kval min)
	   (setf min kval)
	   (lvec->list! idx min-idx))))
     (values min min-idx)))
