(in-package :matlisp)

(defgeneric norm (vec &optional n))
(define-tensor-method norm ((vec numeric-tensor :input) &optional (n 2))
  `(cond
     ((typep n 'real)
      (let-typed ((sum (t/fid+ ,(field-type (cl vec))) :type ,(field-type (cl vec))))
	(dorefs (idx (dimensions vec))
		((ref vec :type ,(cl vec)))
	  (setf sum (t/f+ ,(field-type (cl vec)) sum (expt (abs ref) n))))
	(expt sum (/ n))))
     ((eql n :sup)
      (tensor-foldl ,(cl vec) max vec (t/fid+ ,(field-type (cl vec))) :key abs))))

(defgeneric tensor-max (vec &optional key))
(define-tensor-method tensor-max ((vec standard-tensor :input) &optional key)
  `(if key
       (let* ((ridx (make-list (order vec) :initial-element 0))
	      (rval (funcall key (ref vec ridx))))
	 (dorefs (idx (dimensions vec))
		 ((ref vec :type ,(cl vec)))
	   (let ((kval (funcall key ref)))
	     (when (> kval rval)
	       (setf rval kval)
	       (lvec->list! idx ridx))))
	 (values rval ridx))
       (let*-typed ((ridx (make-list (order vec) :initial-element 0))
		    (rval (ref vec ridx) :type ,(field-type (cl vec))))
	 (dorefs (idx (dimensions vec))
		 ((ref vec :type ,(cl vec)))
	   (let-typed ((r ref :type ,(field-type (cl vec))))
	     (when (> r rval)
	       (setf rval r)
	       (lvec->list! idx ridx))))
	 (values rval ridx))))

(defgeneric tensor-min (vec &optional key))
(define-tensor-method tensor-min ((vec standard-tensor :input) &optional key)
    `(if key
       (let* ((ridx (make-list (order vec) :initial-element 0))
	      (rval (funcall key (ref vec ridx))))
	 (dorefs (idx (dimensions vec))
		 ((ref vec :type ,(cl vec)))
	   (let ((kval (funcall key ref)))
	     (when (< kval rval)
	       (setf rval kval)
	       (lvec->list! idx ridx))))
	 (values rval ridx))
       (let*-typed ((ridx (make-list (order vec) :initial-element 0))
		    (rval (ref vec ridx) :type ,(field-type (cl vec))))
	 (dorefs (idx (dimensions vec))
		 ((ref vec :type ,(cl vec)))
	   (let-typed ((r ref :type ,(field-type (cl vec))))
	     (when (< r rval)
	       (setf rval r)
	       (lvec->list! idx ridx))))
	 (values rval ridx))))

(defun tr (mat)
  (sum (tricopy! mat (zeros (lvec-min (dimensions mat)) (class-of mat)) :d)))
