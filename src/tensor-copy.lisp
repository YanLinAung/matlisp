(in-package :matlisp)

(defun tensor-copy (from to)
  (declare (type real-tensor to from))
    (let ((st-f (store from))
	  (st-t (store to)))
      (declare (type (real-array *) st-f st-t))
      (very-quickly
	(mod-dotimes (idx (dimensions from))
	   with (linear-sums
		 (of-t (strides to) (head to))
		 (of-f (strides from) (head from)))
	   do (setf (aref st-t of-t) (aref st-f of-f))))))

#+nil(let ((x (make-real-tensor-dims 100 100 100))
      (y (make-real-tensor-dims 100 100 100)))
  (mod-loop (idx #(100 100 100))
    (declare (type real-tensor x y))
    (setf (tensor-ref x idx) (random 1d0)))
  (time (tensor-copy x y)))

(defun test-mm (n)
  (let ((t-a (make-real-tensor-dims n n))
	(t-b (make-real-tensor-dims n n))
	(t-c (make-real-tensor-dims n n)))
    (declare (type real-tensor t-a t-b t-c))
    (let ((st-a (store t-a))
	  (st-b (store t-b))
	  (st-c (store t-c)))
      (declare (type (real-array *) st-a st-b st-c))
      (mod-dotimes (idx (dimensions t-a))
	with (linear-sums
	      (of-a (strides t-a))
	      (of-b (strides t-b))
	      (of-c (strides t-c)))
	do (setf (aref st-a of-a) (random 1d0)
		 (aref st-b of-b) (random 1d0)
		 (aref st-c of-c) 0d0))
      (time
       (very-quickly
	 (mod-dotimes (idx (idxv n n n))
	   with (loop-order :row-major)
	   with (linear-sums
		 (of-a (idxv n 1 0))
		 (of-b (idxv 0 n 1))
		 (of-c (idxv n 0 1)))
	   do (incf (aref st-c of-c) (* (aref st-a of-a) (aref st-b of-b)))))))))

(defun test-mm (n)
  (let* ((t-a (make-real-tensor-dims n n))
	 (t-b (make-real-tensor-dims n n))
	 (t-c (make-real-tensor-dims n n))
	 (st-a (store t-a))
	 (st-b (store t-b))
	 (st-c (store t-c)))
    (declare (type real-tensor t-a t-b t-c)
	     (type (real-array *) st-a st-b st-c))
    (mod-dotimes (idx (dimensions t-a))
      with (linear-sums
	    (of-a (strides t-a))
	    (of-b (strides t-b))
	    (of-c (strides t-c)))
      do (setf (aref st-a of-a) (random 1d0)
	       (aref st-b of-b) (random 1d0)
	       (aref st-c of-c) 0d0))
    (time     
     (very-quickly
       (mod-dotimes (idx (idxv n n))
	 with (loop-order :row-major)
	 with (linear-sums
	       (of-a (idxv n 0))
	       (of-b (idxv 0 1))
	       (of-c (idxv n 1)))
	 do (setf (aref st-c of-c)
		  (ddot n st-a 1 st-b n :head-x of-a :head-y of-b)))))))	      
    
(defmacro generate-typed-copy!-func (func store-type matrix-type blas-func)
  ;;Be very careful when using functions generated by this macro.
  ;;Indexes can be tricky and this has no safety net
  ;;Use only after checking the arguments for compatibility.
  `(defun ,func (mat-a mat-b)
     (declare (type ,matrix-type mat-a mat-b)
	      (optimize (safety 0) (speed 3)))
     (mlet* (((cp-a inc-a sz-a) (blas-copyable-p mat-a) :type (boolean fixnum nil))
	     ((cp-b inc-b sz-b) (blas-copyable-p mat-b) :type (boolean fixnum nil))
	     ((hd-a st-a sz) (slot-values mat-a '(head store number-of-elements)) :type (fixnum (,store-type *) fixnum))
	     ((hd-b st-b) (slot-values mat-b '(head store)) :type (fixnum (,store-type *))))
	    (if (and cp-a cp-b)
		(,blas-func sz st-a inc-a st-b inc-b :head-x hd-a :head-y hd-b)
		(mlet* (((nr-a nc-a rs-a cs-a) (slot-values mat-a '(number-of-rows number-of-cols row-stride col-stride))
			 :type (fixnum fixnum fixnum fixnum))
			((rs-b cs-b) (slot-values mat-b '(row-stride col-stride))
			 :type (fixnum fixnum)))
		       ;;Choose the smaller of the loops
		       (when (> (nrows mat-a) (ncols mat-a))
			 (rotatef nr-a nc-a)
			 (rotatef rs-a cs-a)
			 (rotatef rs-b cs-b))
		       (loop for i from 0 below nr-a
			  do (,blas-func nc-a st-a cs-a st-b cs-b :head-x (+ hd-a (* i rs-a)) :head-y (+ hd-b (* i rs-b)))))))
     mat-b))
;;

(defun test-tensor-1k-dot ()
  (declare (optimize (speed 3) (safety 0)))
  (let ((t-a (make-real-tensor-dims 1000 1000))
	(t-b (make-real-tensor-dims 1000 1000))
	(t-c (make-real-tensor-dims 1000 1000)))
    (declare (type real-tensor t-a t-b t-c))
    (let ((s-a (store t-a))
	  (s-b (store t-b))
	  (s-c (store t-c)))
      (declare (type (real-array 1000000) s-a s-b s-c))
      (dotimes (i (* 1000 1000))
	(setf (aref s-a i) (random 1d0))
	(setf (aref s-b i) (random 1d0)))
      (time
       (loop for n from 0 below (the index-type (* 1000 1000)) do
	    (multiple-value-bind (i j) (floor n 1000)
	      (declare (type index-type i j))
	      (setf (aref s-c (+ (* i 1000) j))
		    (loop for k from 0 below 1000
			 summing (* (aref s-a (+ (* i 1000) k)) (aref s-b (+ (* k 1000) j)))))))))))

