(in-package :matlisp)

(defparameter *lisp-copy-upper-bound* 1000
  "When (< (store-size te) *LISP-COPY-UPPER-BOUND*) the method defined in Lisp
is used, else the fortran routine is called instead.
")

(defun column-major-p (offsets dims)
  (loop
     for off across offsets
     and dim across dims
     and accumulated-off = 1 then (* accumulated-off dim)
     unless (= off accumulated-off) do (return nil)
     finally (return t)))

(defun row-major-p (offsets dims)
  (very-quickly
    (loop
       for idx of-type index-type from (1- (length dims)) downto 0
       for dim of-type index-type = (aref dims idx)
       for off of-type index-type = (aref offsets idx)
       and accumulated-off of-type index-type = 1 then (* accumulated-off dim)
       unless (= off accumulated-off) do (return nil)
       finally (return t))))
       

;;
(defun tensor-copy (from to)
  (declare (optimize (speed 3) (safety 0))
	   (type real-tensor to from))
  (let* ((rank (rank to))
	 (dims (dimensions to))
	 (t-strides (strides to))
	 (f-strides (strides from))
	 (t-store (store to))
	 (f-store (store from))
	 (idx (allocate-index-store rank)))
    (declare (type (index-array *) dims t-strides f-strides idx))
    (declare (type (real-array *) t-store f-store))
    (loop
       with of-t of-type index-type = (head to)
       with of-f of-type index-type = (head from)
       do (setf (aref t-store of-t) (aref f-store of-f))
       while (dotimes (i rank nil)
	       (incf (aref idx i))
	       (incf of-t (aref t-strides i))
	       (incf of-f (aref f-strides i))
	       (when (< (aref idx i) (aref dims i)) (return t))
	       (setf (aref idx i) 0)
	       (decf of-t (* (aref t-strides i) (aref dims i)))
	       (decf of-f (* (aref f-strides i) (aref dims i)))))))


(defmacro generate-typed-copy!-func (func store-type matrix-type blas-func)
  ;;Be very careful when using functions generated by this macro.
  ;;Indexes can be tricky and this has no safety net
  ;;Use only after checking the arguments for compatibility.
  `(defun ,func (mat-a mat-b)
     (declare (type ,matrix-type mat-a mat-b)
	      (optimize (safety 0) (speed 3)))
     (mlet* (((cp-a inc-a sz-a) (blas-copyable-p mat-a) :type (boolean fixnum nil))
	     ((cp-b inc-b sz-b) (blas-copyable-p mat-b) :type (boolean fixnum nil))
	     ((hd-a st-a sz) (slot-values mat-a '(head store number-of-elements)) :type (fixnum (,store-type *) fixnum))
	     ((hd-b st-b) (slot-values mat-b '(head store)) :type (fixnum (,store-type *))))
	    (if (and cp-a cp-b)
		(,blas-func sz st-a inc-a st-b inc-b :head-x hd-a :head-y hd-b)
		(mlet* (((nr-a nc-a rs-a cs-a) (slot-values mat-a '(number-of-rows number-of-cols row-stride col-stride))
			 :type (fixnum fixnum fixnum fixnum))
			((rs-b cs-b) (slot-values mat-b '(row-stride col-stride))
			 :type (fixnum fixnum)))
		       ;;Choose the smaller of the loops
		       (when (> (nrows mat-a) (ncols mat-a))
			 (rotatef nr-a nc-a)
			 (rotatef rs-a cs-a)
			 (rotatef rs-b cs-b))
		       (loop for i from 0 below nr-a
			  do (,blas-func nc-a st-a cs-a st-b cs-b :head-x (+ hd-a (* i rs-a)) :head-y (+ hd-b (* i rs-b)))))))
     mat-b))


(defun real-typed-copy!-func (ten-a ten-b)
  


(defun find-longest-chain (stds dims))
  
;; (defun tensor-copy (to from)
;;   (declare (optimize (speed 3) (safety 0))
;; 	   (type real-tensor to from))
;;   (let* ((rank (rank to))
;; 	 (dims (dimensions to))
;; 	 (t-strides (strides to))
;; 	 (f-strides (strides from))
;; 	 (t-store (store to))
;; 	 (f-store (store from))
;; 	 (idx (allocate-index-store rank)))
;;     (declare (type (index-array *) dims t-strides f-strides idx)
;; 	     (type (real-array *) t-store f-store))
;;     (loop
;;        with of-t of-type index-type = (head to)
;;        with of-f of-type index-type = (head from)
;;        do (setf (aref t-store of-f) (aref f-store of-f))
;;        while (dotimes (i rank nil)
;; 	       (incf (aref idx i))
;; 	       (incf of-t (aref t-strides i))
;; 	       (incf of-f (aref f-strides i))
;; 	       (when (< (aref idx i) (aref dims i)) (return t))
;; 	       (setf (aref idx i) 0)
;; 	       (decf of-t (* (aref t-strides i) (aref dims i)))
;; 	       (decf of-f (* (aref f-strides i) (aref dims i)))))))

;; (cffi:define-foreign-library strided-copy
;;   (t (:default "/home/neptune/devel/matlisp/csrc/libtcopy")))

;; (cffi:use-foreign-library strided-copy)

;; (cffi:defcfun ("tcopy_" fortran-tcopy) :void
;;   (rank :pointer :int64) (dims :pointer :int64)
;;   (head-t :pointer :int64) (strides-t :pointer :int64) (data-t :pointer :double)
;;   (head-f :pointer :int64) (strides-f :pointer :int64) (data-f :pointer :double)
;;   (idx-work :pointer :int64))

;; (defun tcopy (rank dims head-t strides-t data-t head-f strides-f data-f idx-work)
;;   (with-foreign-objects-stacked ((r :int64 :initial-element rank)
;; 				 (ht :int64 :initial-element head-t)
;; 				 (hf :int64 :initial-element head-f))
;;     (fortran-tcopy r (sb-sys:vector-sap dims)
;; 		   ht (sb-sys:vector-sap strides-t) (sb-sys:vector-sap data-t)
;; 		   hf (sb-sys:vector-sap strides-f) (sb-sys:vector-sap data-f)
;; 		   (sb-sys:vector-sap idx-work))))

;; (cffi:defcfun ("strided_copy" strided-copy) :void
;;   (rank :int64) (dims :pointer :int64)
;;   (head-t :int64) (strides-t :pointer :int64) (data-t :pointer :double)
;;   (head-f :int64) (strides-f :pointer :int64) (data-f :pointer :double)
;;   (idx-work :pointer :int64))

;; (let* ((idx (allocate-index-store (rank x))))
;;   (time (strided-copy (rank x) (sb-sys:vector-sap (dimensions x))
;; 		(head x) (sb-sys:vector-sap (strides x)) (vector-data-address (store x))
;; 		(head y) (sb-sys:vector-sap (strides y)) (vector-data-address (store y))
;; 		(sb-sys:vector-sap idx))))



;;
#+nil
(defun test-tensor-1k-dot ()
  (declare (optimize (speed 3) (safety 0)))
  (let ((t-a (make-real-tensor 1000 1000))
	(t-b (make-real-tensor 1000 1000))
	(t-c (make-real-tensor 1000 1000)))
    (declare (type real-tensor t-a t-b t-c))
    (let ((s-a (store t-a))
	  (s-b (store t-b))
	  (s-c (store t-c)))
      (declare (type (real-array 1000000) s-a s-b s-c))
      (dotimes (i (* 1000 1000))
	(setf (aref s-a i) (random 1d0))
	(setf (aref s-b i) (random 1d0)))
      (time
       (loop for n from 0 below (the index-type (* 1000 1000)) do
	    (multiple-value-bind (i j) (floor n 1000)
	      (declare (type index-type i j))
	      (setf (aref s-c (+ (* i 1000) j))
		    (ddot 1000 (vector-data-address s-a) 1 (vector-data-address s-b) 1000 :head-x (* i 1000) :head-y j))))))))

