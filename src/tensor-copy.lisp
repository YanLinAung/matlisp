(in-package :matlisp)

(defun tensor-copy (from to)
  (declare (optimize (speed 3) (safety 0) (space 0))
	   (type real-tensor to from))
  (let ((dims (dimensions from)))
    (mod-loop (idx dims)
      (declare (type real-tensor to from)
	       (optimize (speed 3) (safety 0) (space 0)))
      (setf (tensor-ref to idx) (tensor-ref from idx)))))

#+nil(let ((x (make-real-tensor-dims 100 100 100))
      (y (make-real-tensor-dims 100 100 100)))
  (mod-loop (idx #(100 100 100))
    (declare (type real-tensor x y))
    (setf (tensor-ref x idx) (random 1d0)))
  (time (tensor-copy x y)))

(defmacro generate-typed-copy!-func (func store-type matrix-type blas-func)
  ;;Be very careful when using functions generated by this macro.
  ;;Indexes can be tricky and this has no safety net
  ;;Use only after checking the arguments for compatibility.
  `(defun ,func (mat-a mat-b)
     (declare (type ,matrix-type mat-a mat-b)
	      (optimize (safety 0) (speed 3)))
     (mlet* (((cp-a inc-a sz-a) (blas-copyable-p mat-a) :type (boolean fixnum nil))
	     ((cp-b inc-b sz-b) (blas-copyable-p mat-b) :type (boolean fixnum nil))
	     ((hd-a st-a sz) (slot-values mat-a '(head store number-of-elements)) :type (fixnum (,store-type *) fixnum))
	     ((hd-b st-b) (slot-values mat-b '(head store)) :type (fixnum (,store-type *))))
	    (if (and cp-a cp-b)
		(,blas-func sz st-a inc-a st-b inc-b :head-x hd-a :head-y hd-b)
		(mlet* (((nr-a nc-a rs-a cs-a) (slot-values mat-a '(number-of-rows number-of-cols row-stride col-stride))
			 :type (fixnum fixnum fixnum fixnum))
			((rs-b cs-b) (slot-values mat-b '(row-stride col-stride))
			 :type (fixnum fixnum)))
		       ;;Choose the smaller of the loops
		       (when (> (nrows mat-a) (ncols mat-a))
			 (rotatef nr-a nc-a)
			 (rotatef rs-a cs-a)
			 (rotatef rs-b cs-b))
		       (loop for i from 0 below nr-a
			  do (,blas-func nc-a st-a cs-a st-b cs-b :head-x (+ hd-a (* i rs-a)) :head-y (+ hd-b (* i rs-b)))))))
     mat-b))

(defun test-mm ()
  (let ((t-a (make-real-tensor 1000 1000))
	(t-b (make-real-tensor 1000 1000))
	(t-c (make-real-tensor 1000 1000)))
    (declare (type real-tensor t-a t-b t-c))
    (mod-loop (idx #(1000 1000))
      (setf (tensor-ref t-c idx)
	    (loop for k from 0 below 1000
	       summing (* (tensor-ref t-a `(,(aref idx 0) ,k)) (tensor-ref t-b `(,k ,(aref idx 1)))))))))
;;
#+nil
(defun test-tensor-1k-dot ()
  (declare (optimize (speed 3) (safety 0)))
  (let ((t-a (make-real-tensor 1000 1000))
	(t-b (make-real-tensor 1000 1000))
	(t-c (make-real-tensor 1000 1000)))
    (declare (type real-tensor t-a t-b t-c))
    (let ((s-a (store t-a))
	  (s-b (store t-b))
	  (s-c (store t-c)))
      (declare (type (real-array 1000000) s-a s-b s-c))
      (dotimes (i (* 1000 1000))
	(setf (aref s-a i) (random 1d0))
	(setf (aref s-b i) (random 1d0)))
      (time
       (loop for n from 0 below (the index-type (* 1000 1000)) do
	    (multiple-value-bind (i j) (floor n 1000)
	      (declare (type index-type i j))
	      (setf (aref s-c (+ (* i 1000) j))
		    (ddot 1000 (vector-data-address s-a) 1 (vector-data-address s-b) 1000 :head-x (* i 1000) :head-y j))))))))

