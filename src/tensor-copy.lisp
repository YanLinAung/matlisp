(in-package :matlisp)

(defun tensor-copy (from to)
  (declare (optimize (speed 3) (safety 0) (space 0))
	   (type real-tensor to from))
  (let ((dims (dimensions from)))
    (mod-loop (idx dims)
      (declare (type real-tensor to from)
	       (optimize (speed 3) (safety 0) (space 0)))
      (setf (tensor-ref to idx) (tensor-ref from idx)))))

#+nil(let ((x (make-real-tensor-dims 100 100 100))
      (y (make-real-tensor-dims 100 100 100)))
  (mod-loop (idx #(100 100 100))
    (declare (type real-tensor x y))
    (setf (tensor-ref x idx) (random 1d0)))
  (time (tensor-copy x y)))

(defun test-mm (n)
  (let ((t-a (make-real-tensor-dims n n))
	(t-b (make-real-tensor-dims n n))
	(t-c (make-real-tensor-dims n n)))
    (declare (type real-tensor t-a t-b t-c))
    (with-optimization (:speed 3 :safety 0 :space 0)
      (let ((st-a (store t-a))
	    (st-b (store t-b))
	    (st-c (store t-c)))
	(declare (type (real-array *) st-a st-b st-c))
	(mod-dotimes (idx (dimensions t-a))
	  with (linear-sums
		(of-a (strides t-a))
		(of-b (strides t-b))
		(of-c (strides t-c)))
	  do (setf (aref st-a of-a) (random 1d0)
		   (aref st-b of-b) (random 1d0)
		   (aref st-c of-c) 0d0))
	(time (mod-dotimes (idx (idxv n n n))
		with (loop-order :row-major)
		with (linear-sums
		      (of-a (idxv n 1 0))
		      (of-b (idxv 0 n 1))
		      (of-c (idxv n 0 1)))
		do (incf (aref st-c of-c) (* (aref st-a of-a) (aref st-b of-b)))))))))

    
(defun test-mm ()
  (let ((t-a (make-real-tensor-dims 1000 1000))
	(t-b (make-real-tensor-dims 1000 1000))
	(t-c (make-real-tensor-dims 1000 1000)))
    (declare (type real-tensor t-a t-b t-c))
    (mod-loop (idx #(1000 1000))
      (declare (type real-tensor t-a t-b))
      (setf (tensor-ref t-a idx) (random 1d0)
	    (tensor-ref t-b idx) (random 1d0)))
    (let* ((sr-a (strides t-a))
	   (st-a (store t-a))
	   (sr-b (strides t-b))
	   (st-b (store t-b))
	   (sr-c (strides t-c))
	   (st-c (store t-c))
	   (dims (dimensions t-a))
	   (rank 2)
	   (idx (allocate-index-store rank)))
      (declare (type (index-array *) sr-a sr-b sr-c dims idx)
	       (type (real-array *) st-a st-b st-c))
      (time (very-quickly
	(loop
	   with of-a of-type index-type = (head t-a)
	   with of-b of-type index-type = (head t-b)
	   with of-c of-type index-type = (head t-c)
	   do (incf (aref st-c of-c) (* (aref st-a of-a) (aref st-b of-b)))
	   while (loop
		    for i of-type index-type from (1- rank) downto 0
		    do (if (= (aref idx i) (1- (aref dims i)))
			   (progn
			     (setf (aref idx i) 0)
			     (decf of-a (* (1- (aref dims i))
	   

	    (loop for k from 0 below 1000
	       summing (* (tensor-ref t-a `(,(aref idx 0) ,k)) (tensor-ref t-b `(,k ,(aref idx 1)))))))))

(defmacro generate-typed-copy!-func (func store-type matrix-type blas-func)
  ;;Be very careful when using functions generated by this macro.
  ;;Indexes can be tricky and this has no safety net
  ;;Use only after checking the arguments for compatibility.
  `(defun ,func (mat-a mat-b)
     (declare (type ,matrix-type mat-a mat-b)
	      (optimize (safety 0) (speed 3)))
     (mlet* (((cp-a inc-a sz-a) (blas-copyable-p mat-a) :type (boolean fixnum nil))
	     ((cp-b inc-b sz-b) (blas-copyable-p mat-b) :type (boolean fixnum nil))
	     ((hd-a st-a sz) (slot-values mat-a '(head store number-of-elements)) :type (fixnum (,store-type *) fixnum))
	     ((hd-b st-b) (slot-values mat-b '(head store)) :type (fixnum (,store-type *))))
	    (if (and cp-a cp-b)
		(,blas-func sz st-a inc-a st-b inc-b :head-x hd-a :head-y hd-b)
		(mlet* (((nr-a nc-a rs-a cs-a) (slot-values mat-a '(number-of-rows number-of-cols row-stride col-stride))
			 :type (fixnum fixnum fixnum fixnum))
			((rs-b cs-b) (slot-values mat-b '(row-stride col-stride))
			 :type (fixnum fixnum)))
		       ;;Choose the smaller of the loops
		       (when (> (nrows mat-a) (ncols mat-a))
			 (rotatef nr-a nc-a)
			 (rotatef rs-a cs-a)
			 (rotatef rs-b cs-b))
		       (loop for i from 0 below nr-a
			  do (,blas-func nc-a st-a cs-a st-b cs-b :head-x (+ hd-a (* i rs-a)) :head-y (+ hd-b (* i rs-b)))))))
     mat-b))
;;

(defun test-tensor-1k-dot ()
  (declare (optimize (speed 3) (safety 0)))
  (let ((t-a (make-real-tensor-dims 1000 1000))
	(t-b (make-real-tensor-dims 1000 1000))
	(t-c (make-real-tensor-dims 1000 1000)))
    (declare (type real-tensor t-a t-b t-c))
    (let ((s-a (store t-a))
	  (s-b (store t-b))
	  (s-c (store t-c)))
      (declare (type (real-array 1000000) s-a s-b s-c))
      (dotimes (i (* 1000 1000))
	(setf (aref s-a i) (random 1d0))
	(setf (aref s-b i) (random 1d0)))
      (time
       (loop for n from 0 below (the index-type (* 1000 1000)) do
	    (multiple-value-bind (i j) (floor n 1000)
	      (declare (type index-type i j))
	      (setf (aref s-c (+ (* i 1000) j))
		    (loop for k from 0 below 1000
			 summing (* (aref s-a (+ (* i 1000) k)) (aref s-b (+ (* k 1000) j)))))))))))

