(in-package :matlisp)

(defun graph->adlist (g)
  (declare (type graph-accessor g))
  (iter (for i from 0 below (1- (length (fence g))))
	(collect (δ-i g i t) result-type vector)))

(defun adlist->graph (ag)
  (let ((fe (t/store-allocator index-store-vector (1+ (length ag))))
	(nv (t/store-allocator index-store-vector (iter (for ai in-vector ag) (summing (length ai))))))
    (iter (for i from 0 below (length ag))
	  (setf (aref ag i) (sort (aref ag i) #'(lambda (x y) (declare (type index-type x y)) (< x y))))
	  (iter (for nj in (aref ag i))
		(setf (aref nv (+ (aref fe i) j)) nj)
		(counting t into j)
		(finally (setf (aref fe (1+ i)) (+ (aref fe i) j)))))
    (make-instance 'graph-accessor :dimensions (idxv (length ag) (length ag)) :fence fe :neighbours nv)))

(defun cliquep (g lst)
  (iter main (for u* on lst)
    (iter (for v in (cdr u*)) (or (δ-i g (car u*) v) (return-from main nil)))
    (finally (return-from main t))))

;;Oh may we weep for sins!
(defun moralize! (adg)
  (let ((cadg (make-array (length adg) :initial-element nil)))
    (iter (for u from 0 below (length adg))
	  (iter (for v in (aref adg u))
		(push u (aref cadg v))))
    (iter (for u from 0 below (length adg))
	  (iter (for v in (aref cadg u))
		(setf (aref adg v) (union (aref adg v) (aref cadg u)))))
    adg))

(defun symmetrize! (adg)
  (iter (for u from 0 below (length adg))
	(iter (for v in (aref adg u))
	      (setf (aref adg v) (union (aref adg v) (list u)))))
  adg)
;;
(defun graph-queue (init g)
  (declare (type graph-accessor g))
  (let* ((queue (fib:make-heap #'(lambda (a b) (if (and a b) (< a b) (and a t))))))
    (iter (for i from 0 below (1- (length (fence g)))) (fib:insert-key (funcall init g i) queue))
    queue))

(defmacro graphfib ((g graph &key order iterate block-name) init update &rest body)
  (with-gensyms (fe queue)
    (destructuring-bind (init-sym (i) &rest init-body) init
      (assert (eql init-sym :init) nil "key mismatch.")
      (destructuring-bind (update-sym (j w-j fib) &rest update-body) update
	(assert (eql update-sym :update) nil "key mismatch.")
	`(block ,block-name
	   (let*-typed ((,g ,graph :type graph-accessor)
			(,fe (fence ,g) :type index-store-vector)
			(,fib (let* ((,queue (fib:make-heap ,(or order #'(lambda (a b) (if (and a b) (< a b) (and a t)))))))
				(iter (for ,i from 0 below (1- (length (fence ,g)))) (fib:insert-key (progn ,@init-body) ,queue))
				,queue)))
	     (iter (until (= (total-size fib) 0))
		   ,@(when iterate
			   (letv* (((lvar ldir) iterate))
			     `((for ,lvar initially ,@(ecase ldir (:up `(0 then (1+ ,lvar))) (:down `((- (length ,fe) 2) then (1- ,lvar))))))))
		   (letv* ((,w-j ,j (fib:extract-min ,fib) :type t index-type))
		     ,@update-body))
	     ,@body))))))
;;
(defun max-cardinality-search (g &optional start)
  (let* ((order (t/store-allocator index-store-vector (1- (length (fence g)))))
	 (start (or start (random (length order))))
	 (cliques nil)
	 (k (1- (length (fence g)))) (stack nil))
    (graphfib (g g :order (lambda (x y) (> x y)))
      (:init (i) (if (= i start) 1 0))
      (:update (i w-i fib)	       
	       (letv* ((li ri (fence g i))
		       (δ-clique (iter (for j in-vector (δ-i g) from li below ri) (when (or (member j stack) (fib:node-existsp j fib)) (collect j)))))		 
		 (if (cliquep g δ-clique)
		     (iter (for j in-vector (δ-i g) from li below ri) (incf (fib:node-key j fib))
			   (finally (setf (aref order (decf k)) i)
				    (setf cliques (let ((c (list (cons i δ-clique)))) (union cliques (union c cliques :test #'subsetp) :test #'subsetp)))
				    (iter (for u in stack) (fib:insert-key (fib:node-key u fib) fib u) (finally (setf stack nil)))))
		     (push i stack))))
      (unless stack (values order cliques)))))

;;Naive-implementation, can't use graphfib because of non-monotonicity
;;Use union-find/hash-table in place of list for sets.
(defun triangulate-graph (g &optional (heuristic :min-fill))
  (let* ((ag (graph->adlist g))
	 (chordal-cover (make-array (length ag)))
	 (ord (t/store-allocator index-store-vector (length ag))))
    (flet ((cliquify (u)
	     (iter (for v in (aref ag u))
		   (setf (aref ag v) (set-difference (union (aref ag v) (aref ag u)) (list u v))))
	     (setf
	      (aref chordal-cover u) (aref ag u)
	      (aref ag u) t))
	   (δ-size (i) (length (aref ag i)))
	   (k-size (i) (iter main (for u* on (aref ag i))
			     (iter (for v in (cdr u*)) (unless (find (car u*) (aref ag v)) (in main (counting t)))))))
      (iter (for i from 0 below (length ord))
	    (setf (aref ord i) (iter (for i from 0 below (length ag))
				     (unless (eql (aref ag i) t)
				       (finding i minimizing (ecase heuristic (:min-fill (δ-size i)) (:min-size (k-size i)))))))
	    (cliquify (aref ord i))))
    (values ord (adlist->graph chordal-cover))))


#+nil
(letv* ((ag (symmetrize! #((1) (2) (0 3) (4) (0))))
	(g (adlist->graph ag)))
  ;;(max-cardinality-search (nth-value 1 (triangulate-graph g :min-size)))
  ;;(max-cardinality-search g)
  (moralize! #(() (0) (0) (0) (2) (2))))

;;
(defun dijkstra (g &optional start)
  (let* ((tree (t/store-allocator index-store-vector (dimensions g 0)))
	 (start (or start (random (length tree)))))
    (setf (aref tree start) start)
    (graphfib (g g :order (lambda (x y) (or (and y (< x y)) x)))
      (:init (i) (if (= i start) 0 nil))
      (:update (i d-i fib)
	 (letv* ((li ri (fence g i)))
	   (iter (for j in-vector (δ-i g) from li below ri)
		 (when (fib:node-existsp j fib)
		   (let ((d-j+ (+ d-i (ref g i j))))
		     (when (< d-j+ (fib:node-key j fib))
		       (setf (fib:node-key j fib) d-j+
			     (aref tree j) i)))))))
      tree)))

(defun dijkstra-prims (g &optional start)
  (let* ((tree (t/store-allocator index-store-vector (dimensions g 0)))
	 (start (or start (random (length tree)))))
    (setf (aref tree start) start)
    (graphfib (g g :order (lambda (x y) (< x y)))
      (:init (i) (if (= i start) -1 0))
      (:update (i w-i fib)
	 (letv* ((li ri (fence g i)))
	   (iter (for j in-vector (δ-i g) from li below ri)		 
		 (when (fib:node-existsp j fib)
		   (let ((w-ij (ref g i j)))
		     (when (< w-ij (fib:node-key j fib))
		       (setf (fib:node-key j fib) w-ij
			     (aref tree j) i)))))))
      tree)))
;;
