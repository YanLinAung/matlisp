(in-package #:matlisp-utilities)

(eval-every

(let ((code `(lambda (val lb ub vec &key (order #'<) (test #'=))
	       (declare (type fixnum lb ub)
			(type vector vec))
	       (cond
		 ((or (= lb ub) (funcall order val (aref vec lb))) (values nil lb))
		 ((funcall order (aref vec (1- ub)) val) (values nil ub))
		 (t (loop :for j :of-type fixnum := (floor (+ lb ub) 2)
		       :repeat #.(ceiling (log array-dimension-limit 2))
		       :do (cond ((funcall test (aref vec j) val) (return j))
				 ((>= lb (1- ub)) (return (values nil (if (funcall order (aref vec lb) val) (1+ lb) lb))))
				 (t (if (funcall order val (aref vec j))
					(setf ub j)
					(setf lb (1+ j)))))))))))
  (setf (symbol-function 'binary-search) (compile nil code))
  (define-compiler-macro binary-search (&whole form val lb ub vec &key (order '(function <)) (test '(function =)))
    (letv* ((vtype-givenp (and (consp vec) (eql (first vec) 'the)))
	    ((inline-orderp inline-testp) (mapcar #'(lambda (x)	(and (consp x)
								     (match x
								       ((list 'quote (guard x (symbolp x))) t)
								       ((list 'function x) (or (symbolp x)
											       (match x ((list* 'lambda (list a b) _) (ziprm (and symbolp) (a b))))))
								       ((list* 'lambda (list a b) _) (ziprm (and symbolp) (a b))))))
						  (list order test))))
      (if (or vtype-givenp inline-orderp inline-testp)
	  (let ((code (maptree-if #'(lambda (x) (and (consp x) (or (and vtype-givenp (equal x '(type vector vec)))
								   (let ((x2 (subseq x 0 2)))
								     (or (and inline-orderp (equal x2 '(funcall order)))
									 (and inline-testp (equal x2 '(funcall test))))))))
				  #'(lambda (x)
				      (if (and vtype-givenp (equal (first x) 'type))
					  `(type ,(second vec) vec)
					  (if-let (code (ecase (second x) (order (and inline-orderp order)) (test (and inline-testp test))))
					    (match code
					      ((list (or 'function 'quote) (guard f (symbolp f))) `(,(second code) ,@(cddr x)))
					      ((list 'function (list* 'lambda _)) (let ((code (second code))) `(let (,@(zip (second code) (cddr x))) ,@(cddr code))))
					      ((list* 'lambda _) `(let (,@(zip (second code) (cddr x))) ,@(cddr code)))
					      (_ (error "can't parse pattern ~a" code)))
					    x)))
				  (cddr code)))
		(decl (zip (subseq (second code) 0 4) (cdr form))))
	    `(let (,@decl
		   ,@(unless inline-orderp `((order ,order)))
		   ,@(unless inline-testp `((test ,test))))
	       ,@code))
	  form))))
)
