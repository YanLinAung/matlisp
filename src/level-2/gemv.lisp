(in-package #:matlisp)

(defmacro generate-typed-gemv! (func
				(matrix-class vector-class)
				(blas-gemv-func blas-axpy-func blas-dot-func blas-scal-func))
  ;;Be very careful when using functions generated by this macro.
  ;;Indexes can be tricky and this has no safety net.
  ;;Use only after checking the arguments for compatibility.
  (let* ((opt (get-tensor-class-optimization matrix-class)))
    (assert opt nil 'tensor-cannot-find-optimization :tensor-class matrix-class)
    `(defun ,func (alpha A x beta y job)
       (declare (type ,(getf opt :element-type) alpha beta)
		(type ,matrix-class A)
		(type ,vector-class x y)
		(type symbol job))
       (mlet*
	(((maj-a ld-a fop-a) (blas-matrix-compatible-p A job) :type (symbol index-type (string 1))))
	(if maj-a
	    (let ((nr-a (aref (dimensions A) 0))
		  (nc-a (aref (dimensions A) 1)))
	      (declare (type index-type nr-a nc-a))
	      (when (eq maj-a :row-major)
		(rotatef nr-a nc-a))
	      (,blas-gemv-func fop-a nr-a nc-a
			       alpha (store a) ld-a
			       (store x) (aref (strides x) 0)
			       beta
			       (store y) (aref (strides y) 0)
			       (head A) (head x) (head y)))
	    (let ((nr-a (aref (dimensions A) 0))
		  (nc-a (aref (dimensions A) 1))
		  (rs-a (aref (strides A) 0))
		  (cs-a (aref (strides A) 1)))
	      (declare (type index-type nr-a nc-a rs-a cs-a))
	      (when (eq job :t)
		(rotatef nr-a nc-a)
		(rotatef rs-a cs-a))
	      (let ((sto-a (store a))
		    (sto-x (store x))
		    (std-x (aref (strides x) 0))
		    (hd-x (head x))
		    (sto-y (store y))
		    (std-y (aref (strides y) 0))
		    (hd-y (head y)))
		(declare (type ,(linear-array-type (getf opt :store-type)) sto-a sto-x sto-y)
			 (type index-type std-y std-x hd-x hd-y))
		(if (> nr-a nc-a)
		    (progn
		      (unless (= beta 1d0)
			(,blas-scal-func nr-a beta
					 sto-y std-y hd-y))
		      (very-quickly
			(mod-dotimes (idx (idxv nc-a))
			  with (linear-sums
				(of-x (strides x) (head x))
				(of-a (idxv cs-a) (head A)))
			  do (,blas-axpy-func nr-a (* alpha ,(funcall (getf opt :reader) 'sto-x 'of-x))
					      sto-a rs-a sto-y std-y
					      of-a hd-y))))
		    (very-quickly
		      (mod-dotimes (idx (idxv nr-a))
			with (linear-sums 
			      (of-y (strides y) (head y))
			      (of-a (idxv rs-a) (head A)))
			do (let ((val (* beta ,(funcall (getf opt :reader) 'sto-y 'of-y)))
				 (dotp (,blas-dot-func nc-a
						       sto-a cs-a sto-x std-x
						       of-a hd-x)))
			     (declare (type ,(getf opt :element-type) val dotp))
			     ,(funcall (getf opt :value-writer)
				       `(+ val (* alpha dotp)) 'sto-y 'of-y)))))))))
       y)))

(generate-typed-gemv! real-typed-gemv!
		      (real-matrix real-vector)
		      (dgemv daxpy ddot dscal))

(generate-typed-gemv! complex-typed-gemv!
		      (complex-matrix complex-vector)
		      (zgemv zaxpy zdotu zscal))

;;---------------------------------------------------------------;;

;;Can't support "C" because the dual isn't supported by BLAS.
(defgeneric gemv! (alpha A x beta y &optional job)
  (:documentation
"
  Syntax
  ======
  (GEMV! alpha A x beta y [job])

  Purpose
  =======
  Performs the GEneral Matrix Vector operation given by
               --      -      -

            Y <- alpha * op(A) * x + beta * y
     
  and returns y.

  alpha,beta are scalars,
  A is a matrix, and x,y are vectors.

  op(A) means either A or A'.

     JOB                    Operation
  ---------------------------------------------------
     :N (default)      alpha * A * x + beta * y
     :T                alpha * A'* x + beta * y
")
  (:method :before ((alpha number) (A standard-matrix) (x standard-vector)
		    (beta number) (y standard-vector)
		    &optional (job :n))
	   (assert (member job '(:n :t)) nil 'invalid-value
		   :given job :expected `(member job '(:n :t))
		   :message "Inside gemv!")
	   (assert (not (eq x y)) nil 'invalid-arguments
		   :message "GEMV!: x and y cannot be the same vector")
	   (assert (and
		    (= (aref (dimensions x) 0)
		       (aref (dimensions A) (if (eq job :t) 0 1)))
		    (= (aref (dimensions y) 0)
		       (aref (dimensions A) (if (eq job :t) 1 0))))
		   nil 'tensor-dimension-mismatch)))

(defmethod gemv! ((alpha number) (A real-matrix) (x real-vector)
		  (beta number) (y real-vector) &optional (job :n))
  (real-typed-gemv! (coerce-real alpha) A x
		    (coerce-real beta) y job))

(defmethod gemv! ((alpha number) (A complex-matrix) (x complex-vector)
		  (beta number) (y complex-vector) &optional (job :n))
  (complex-typed-gemv! (coerce-complex alpha) A x
		       (coerce-complex beta) y job))

(defmethod gemv! ((alpha number) (A real-matrix) (x real-vector)
		  (beta number) (y complex-vector) &optional (job :n))
  (unless (= beta 1)
    (complex-typed-scal! (coerce-complex beta) y))
  (unless (= alpha 0)
    (if (complexp alpha)
	(let ((A.x (make-real-tensor (aref (dimensions y) 0)))
	      (vw-y (tensor-realpart~ y)))
	  (real-typed-gemv! (coerce-real 1) A x (coerce-real 0) A.x job)
	  ;;
	  (real-typed-axpy! (coerce-real (realpart alpha)) A.x vw-y)
	  ;;Move view to the imaginary part
	  (incf (head vw-y))
	  (real-typed-axpy! (coerce-real (imagpart alpha)) A.x vw-y))
	(real-typed-gemv! (coerce-real alpha) A x
			  (coerce-real 1) (tensor-realpart~ y) job)))
  y)

(defmethod gemv! ((alpha number) (A real-matrix) (x complex-vector)
		  (beta number) (y complex-matrix) &optional (job :n))
  (unless (= beta 1)
    (complex-typed-scal! (coerce-complex beta) y))
  (unless (= alpha 0)
    (let ((A.x (make-complex-tensor (aref (dimensions y) 0))))
      (let ((vw-x (tensor-realpart~ x))
	    (vw-A.x (tensor-realpart~ x)))
	;;Re
	(real-typed-gemv! (coerce-real 1) A vw-x (coerce-real 0) vw-A.x job)
	;;Im
	(incf (head vw-x))
	(incf (head vw-A.x))
	(real-typed-gemv! (coerce-real 1) A vw-x (coerce-real 0) vw-A.x job))
      (complex-typed-axpy! (coerce-complex alpha) A.x y)))
  y)

(defmethod gemv! ((alpha number) (A complex-matrix) (x real-vector)
		  (beta number) (y complex-vector) &optional (job :n))
  (let ((cplx-x (make-complex-tensor (aref (dimensions x) 0))))
    (real-typed-copy! x (tensor-realpart~ cplx-x))
    (complex-typed-gemv! (coerce-complex alpha) A cplx-x
			 (coerce-complex beta) y job))
  y)

;;---------------------------------------------------------------;;
(defgeneric gemv (alpha A x beta y &optional job)
  (:documentation
"
  Syntax
  ======
  (GEMV alpha A x beta y [job])

  Purpose
  =======
  Returns the GEneral Matrix Vector operation given by

            alpha * op(A) * x + beta * y

  alpha,beta are scalars,
  A is a matrix, and x,y are vectors.

  op(A) means either A or A'.

     JOB                    Operation
  ---------------------------------------------------
     :N (default)      alpha * A * x + beta * y
     :T                alpha * A'* x + beta * y
"))

(defmethod gemv ((alpha number) (A standard-matrix) (x standard-vector)
		 (beta number) (y complex-vector) &optional (job :n))
  (let ((result (copy y)))
    (gemv! alpha A x 1d0 result job)))

(defmethod gemv ((alpha number) (A standard-matrix) (x standard-vector)
		 (beta number) (y real-vector) &optional (job :n))
  (let ((result (if (or (complexp alpha) (complexp beta)
			(typep A 'complex-matrix) (typep x'complex-matrix))
		    (make-complex-tensor (aref (dimensions y) 0))
		    (make-real-tensor (aref (dimensions y) 0)))))
    (copy! y result)
    (gemv! alpha A x beta result job)))

