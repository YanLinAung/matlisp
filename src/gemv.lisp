(in-package :matlisp)

;;There's no support for ":c", because there is no
;;equivalent of ":n" with complex conjugation.
(defmacro generate-typed-gemv!-func (func element-type store-type matrix-type blas-gemv-func blas-axpy-func blas-dot-func)
  ;;Be very careful when you use functions generated by this macro!
  ;;Indexes can be tricky and this has no safety net
  ;;Use only after checking the arguments for compatibility.
  `(defun ,func (alpha A x beta y job)
    (declare (type ,element-type alpha beta)
	     (type ,matrix-type A x y)
	     (type symbol job))
    (mlet* ((fort-op (ecase job (:n "N") (:t "T")) :type ((string 1)))
	    ((st-a hd-a nr-a nc-a rs-a cs-a) (slot-values A '(store head number-of-rows number-of-cols row-stride col-stride))
	     :type ((,store-type *) fixnum fixnum fixnum fixnum fixnum))
	    ((st-x hd-x rs-x) (slot-values x '(store head row-stride))
	     :type ((,store-type *) fixnum fixnum))
	    ((st-y hd-y rs-y) (slot-values y '(store head row-stride))
	     :type ((,store-type *) fixnum fixnum))
	    ((sym lda tf-op) (blas-matrix-compatible-p A fort-op) :type (symbol fixnum (string 1))))
	   (if (not (string= tf-op "?"))
	       (progn
		 (when (eq sym :row-major)
		   (rotatef nr-a nc-a)
		   (rotatef rs-a cs-a))
		 (,blas-gemv-func tf-op nr-a nc-a alpha st-a lda st-x rs-x beta st-y rs-y :head-a hd-a :head-x hd-x :head-y hd-y))
	       (progn
		 (when (string= fort-op "T")
		   (rotatef nr-a nc-a)
		   (rotatef rs-a cs-a))
		 ;;Use the smaller of the loops.
		 (if (> nr-a nc-a)
		     (progn
		       (scal! beta y)
		       (dotimes (i nc-a)
			 (,blas-axpy-func nr-a (* alpha (matrix-ref-2d x i 0)) st-a rs-a st-y rs-y :head-x (+ hd-a (* i cs-a)) :head-y hd-y)))
		     (dotimes (i nr-a)
		       (setf (matrix-ref-2d y i 0) (+ (* alpha (,blas-dot-func nc-a st-a cs-a st-x rs-x :head-x (+ hd-a (* i rs-a)) :head-y hd-x))
						      (* beta (matrix-ref-2d y i 0)))))))))
    y))



;;
(defgeneric gemv! (alpha A x beta y &optional job)
  (:documentation
"
  Syntax
  ======
  (GEMV! alpha A x beta y [job])

  Purpose
  =======
  Performs the GEneral Matrix Vector operation given by
               --      -      -

            Y <- alpha * op(A) * x + beta * y
     
  and returns y.

  alpha,beta are scalars,
  A is a matrix, and x,y are vectors.

  op(A) means either A or A'.

     JOB                    Operation
  ---------------------------------------------------
     :N (default)      alpha * A * x + beta * y
     :T                alpha * A'* x + beta * y

 Note
 ====
 Take caution when using GEMM! as follows:

          (GEMV! alpha a x beta x)

  The results may be unpredictable depending
  on the underlying DGEMM, ZGEMM routines
  from BLAS, ATLAS or LIBCRUFT.
"))

(defmethod gemv! :before ((alpha number) (A standard-matrix) (x standard-matrix)
			  (beta number) (y standard-matrix)
			  &optional (job :n))
  (mlet* (((nr-a nc-a) (slot-values A '(number-of-rows number-of-cols)) :type (fixnum fixnum))
	  ((nr-x nc-x) (slot-values x '(number-of-rows number-of-cols)) :type (fixnum fixnum))
	  ((nr-y nc-y) (slot-values y '(number-of-rows number-of-cols)) :type (fixnum fixnum)))
	 (unless (member job '(:n :t))
	   (error "Argument JOB to GEMV! is not recognized"))
	 (when (eq job :t)
	   (rotatef nr-a nc-a))
	 (unless (and (= nc-x 1) (= nc-y 1)
		      (= nc-a nr-x) (= nr-a nr-y))
	   (error "Dimensions of A,x,y given to GEMV! do not match"))))

;;
(generate-typed-gemv!-func real-double-gemv!-typed
			   double-float real-matrix-store-type real-matrix
			   blas:dgemv blas:daxpy blas:ddot)

(defmethod gemv! ((alpha cl:real) (A real-matrix) (x real-matrix)
		  (beta cl:real) (y real-matrix) &optional (job :n))
  (real-double-gemv!-typed (coerce alpha 'double-float) A x
			   (coerce beta 'double-float) y job))

;;
(generate-typed-gemv!-func complex-double-gemv!-typed
			   complex-double-float complex-matrix-store-type complex-matrix
			   blas:zgemv blas:zaxpy blas:zdotu)

(defmethod gemv! ((alpha number) (A complex-matrix) (x complex-matrix)
		  (beta number) (y complex-matrix) &optional (job :n))
  (complex-double-gemv!-typed (complex-coerce alpha) A x
			      (complex-coerce beta) y job))

;
(defmethod gemv! ((alpha cl:real) (A real-matrix) (x real-matrix)
		  (beta cl:real) (y complex-matrix) &optional (job :n))
  (real-double-gemv!-typed (coerce alpha 'double-float) A x
			   (coerce beta 'double-float) (realpart! y) job))

(defmethod gemv! ((alpha cl:real) (A real-matrix) (x real-matrix)
		  (beta complex) (y complex-matrix) &optional (job :n))
  (scal! (complex-coerce beta) y)
  (real-double-gemv!-typed (coerce alpha 'double-float) A x
			   1d0 (realpart! y) job))

;

(defmethod gemv! ((alpha complex) (A real-matrix) (x real-matrix)
		  (beta cl:real) (y complex-matrix) &optional (job :n))
  (real-double-gemv!-typed (coerce (realpart alpha) 'double-float) A x
			   (coerce beta 'double-float) (realpart! y) job)
  (real-double-gemv!-typed (coerce (imagpart alpha) 'double-float) A x
			   (coerce beta 'double-float) (imagpart! y) job))

(defmethod gemv! ((alpha complex) (A real-matrix) (x real-matrix)
		  (beta complex) (y complex-matrix) &optional (job :n))
  (scal! (complex-coerce beta) y)
  (real-double-gemv!-typed (coerce (realpart alpha) 'double-float) A x
			   1d0 (realpart! y) job)
  (real-double-gemv!-typed (coerce (imagpart alpha) 'double-float) A x
			   1d0 (imagpart! y) job))
;

(defmethod gemv! ((alpha number) (A real-matrix) (x complex-matrix)
		  (beta number) (y complex-matrix) &optional (job :n))
  (gemv! alpha A (realpart! x)
	 beta y job)
  (gemv! (* #c(0d0 1d0) alpha) A (imagpart! x)
	 beta y job))
;
(defmethod gemv! ((alpha number) (A complex-matrix) (x real-matrix)
		  (beta number) (y complex-matrix) &optional (job :n))
  (gemv! alpha (realpart! A) x
	 beta y job)
  (gemv! (* #c(0d0 1d0) alpha) (imagpart! A) x
	 beta y job))

 
;
(defun gemv! ((alpha number) (A complex-matrix) (x real-matrix)
	      (beta number) (y complex-matrix))
  )

;;