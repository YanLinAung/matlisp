(in-package :matlisp)

;;There's no support for ":c", because there is no
;;equivalent of ":n" with complex conjugation.
(defmacro generate-typed-gemv!-func (func element-type store-type matrix-type blas-gemv-func blas-axpy-func blas-dot-func)
  ;;Be very careful when you use functions generated by this macro!
  ;;Indexes can be tricky and this has no safety net
  ;;Use only after checking the arguments for compatibility.
  `(defun ,func (alpha A x beta y job)
    (declare (type ,element-type alpha beta)
	     (type ,matrix-type A x y)
	     (type symbol job))
    (mlet* (((st-a hd-a nr-a nc-a rs-a cs-a) (slot-values A '(store head number-of-rows number-of-cols row-stride col-stride))
	     :type ((,store-type *) fixnum fixnum fixnum fixnum fixnum))
	    ((st-x hd-x rs-x) (slot-values x '(store head row-stride))
	     :type ((,store-type *) fixnum fixnum))
	    ((st-y hd-y rs-y) (slot-values y '(store head row-stride))
	     :type ((,store-type *) fixnum fixnum))
	    ((sym lda tf-op) (blas-matrix-compatible-p A job) :type (symbol fixnum (string 1))))
	   (if (not (string= tf-op "?"))
	       (progn
		 (when (eq sym :row-major)
		   (rotatef nr-a nc-a)
		   (rotatef rs-a cs-a))
		 (,blas-gemv-func tf-op nr-a nc-a alpha st-a lda st-x rs-x beta st-y rs-y :head-a hd-a :head-x hd-x :head-y hd-y))
	       (progn
		 (when (eq job :t)
		   (rotatef nr-a nc-a)
		   (rotatef rs-a cs-a))
		 ;;Use the smaller of the loops.
		 (if (> nr-a nc-a)
		     (progn
		       (scal! beta y)
		       (dotimes (i nc-a)
			 (,blas-axpy-func nr-a (* alpha (matrix-ref-2d x i 0)) st-a rs-a st-y rs-y :head-x (+ hd-a (* i cs-a)) :head-y hd-y)))
		     (dotimes (i nr-a)
		       (setf (matrix-ref-2d y i 0) (+ (* alpha (,blas-dot-func nc-a st-a cs-a st-x rs-x :head-x (+ hd-a (* i rs-a)) :head-y hd-x))
						      (* beta (matrix-ref-2d y i 0)))))))))
    y))

;;
(defgeneric gemv! (alpha A x beta y &optional job)
  (:documentation
"
  Syntax
  ======
  (GEMV! alpha A x beta y [job])

  Purpose
  =======
  Performs the GEneral Matrix Vector operation given by
               --      -      -

            Y <- alpha * op(A) * x + beta * y
     
  and returns y.

  alpha,beta are scalars,
  A is a matrix, and x,y are vectors.

  op(A) means either A or A'.

     JOB                    Operation
  ---------------------------------------------------
     :N (default)      alpha * A * x + beta * y
     :T                alpha * A'* x + beta * y

 Note
 ====
 Take caution when using GEMM! as follows:

          (GEMV! alpha a x beta x)

  The results may be unpredictable depending
  on the underlying DGEMM, ZGEMM routines
  from BLAS, ATLAS or LIBCRUFT.
"))

(defmethod gemv! :before ((alpha number) (A standard-matrix) (x standard-matrix)
			  (beta number) (y standard-matrix)
			  &optional (job :n))
  (mlet* (((nr-a nc-a) (slot-values A '(number-of-rows number-of-cols)) :type (fixnum fixnum))
	  ((nr-x nc-x) (slot-values x '(number-of-rows number-of-cols)) :type (fixnum fixnum))
	  ((nr-y nc-y) (slot-values y '(number-of-rows number-of-cols)) :type (fixnum fixnum)))
	 (unless (member job '(:n :t))
	   (error "Argument JOB to GEMV! is not recognized"))
	 (when (eq job :t)
	   (rotatef nr-a nc-a))
	 (unless (and (= nc-x 1) (= nc-y 1)
		      (= nc-a nr-x) (= nr-a nr-y))
	   (error "Dimensions of A,x,y given to GEMV! do not match"))))

;;
(generate-typed-gemv!-func real-double-gemv!-typed
			   double-float real-matrix-store-type real-matrix
			   blas:dgemv blas:daxpy blas:ddot)

(defmethod gemv! ((alpha cl:real) (A real-matrix) (x real-matrix)
		  (beta cl:real) (y real-matrix) &optional (job :n))
  ;; y <- \beta . y + \alpha . A o x
  (real-double-gemv!-typed (coerce alpha 'double-float) A x
			   (coerce beta 'double-float) y job))

;;
(generate-typed-gemv!-func complex-double-gemv!-typed
			   complex-double-float complex-matrix-store-type complex-matrix
			   blas:zgemv blas:zaxpy blas:zdotu)

(defmethod gemv! ((alpha number) (A complex-matrix) (x complex-matrix)
		  (beta number) (y complex-matrix) &optional (job :n))
  ;; y <- \beta . y + \alpha . A o x
  (complex-double-gemv!-typed (complex-coerce alpha) A x
			      (complex-coerce beta) y job))

;
(defmethod gemv! ((alpha cl:real) (A real-matrix) (x real-matrix)
		  (beta complex) (y complex-matrix) &optional (job :n))
  (let ((r-y (mrealpart y)))
    (declare (type real-matrix r-y))
    ;; y <- \beta * y
    (scal! (complex-coerce beta) y)
    ;; y <- y + \alpha * A o x
    (real-double-gemv!-typed (coerce alpha 'double-float) A x 1d0 r-y job)))

(defmethod gemv! ((alpha complex) (A real-matrix) (x real-matrix)
		  (beta complex) (y complex-matrix) &optional (job :n))
  ;; y <- \beta * y
  (scal! (complex-coerce beta) y)
  ;; y <- y + \alpha * A o x
  (gemv! alpha A x 1d0 y job))

(defmethod gemv! ((alpha cl:real) (A real-matrix) (x real-matrix)
		  (beta cl:real) (y complex-matrix) &optional (job :n))
  (let ((r-be (coerce beta 'double-float))
	(r-al (coerce alpha 'double-float))
	(r-y (mrealpart y)))
    (declare (type double-float r-be r-al)
	     (type real-matrix r-y))
    ;; y <- \beta * y
    (scal! r-be y)
    ;; (mrealpart y) <- (mrealpart y) + \alpha * A o x
    (real-double-gemv!-typed r-al A x 1d0 r-y job))
  y)

(defmethod gemv! ((alpha complex) (A real-matrix) (x real-matrix)
		  (beta cl:real) (y complex-matrix) &optional (job :n))
  (let ((r-al (coerce (realpart alpha) 'double-float))
	(i-al (coerce (imagpart alpha) 'double-float))
	(r-be (coerce beta 'double-float))
	(r-y (mrealpart y))
	(i-y (mimagpart y)))
    (declare (type double-float r-al i-al r-be)
	     (type real-matrix r-y i-y))
    ;; (mrealpart y) <- \beta * (mrealpart y) + (realpart \alpha) . A o x
    (real-double-gemv!-typed r-al A x r-be r-y job)
    ;; (mimagpart y) <- \beta * (mimagpart y) + (imagpart \alpha) . A o x
    (real-double-gemv!-typed i-al A x r-be i-y job))
  y)

;
(defmethod gemv! ((alpha number) (A real-matrix) (x complex-matrix)
		  (beta complex) (y complex-matrix) &optional (job :n))
  ;; y <- \beta y
  (scal! beta y)
  ;; y <- y + \alpha . A o x
  (gemv! alpha A x 1d0 y job))

(defmethod gemv! ((alpha cl:real) (A real-matrix) (x complex-matrix)
		  (beta cl:real) (y complex-matrix) &optional (job :n))
  (let ((r-x (mrealpart x))
	(i-x (mimagpart x))
	(r-y (mrealpart y))
	(i-y (mimagpart y))
	(r-al (coerce (realpart alpha) 'double-float))
	(r-be (coerce beta 'double-float)))
    (declare (type double-float r-al r-be)
	     (type real-matrix r-x i-x r-y i-y))
    ;; (mrealpart y) <- \beta * (mrealpart y) + \alpha . A o (mrealpart x)
    (real-double-gemv!-typed r-al A r-x r-be r-y job)
    ;; (mimagpart y) <- \beta * (mimagpart y) + \alpha . A o (mrealpart x)
    (real-double-gemv!-typed r-al A i-x r-be i-y job))
  y)

(defmethod gemv! ((alpha complex) (A real-matrix) (x complex-matrix)
		  (beta cl:real) (y complex-matrix) &optional (job :n))
  (let ((r-x (mrealpart x))
	(i-x (mimagpart x))
	(r-y (mrealpart y))
	(i-y (mimagpart y))
	(r-al (coerce (realpart alpha) 'double-float))
	(i-al (coerce (imagpart alpha) 'double-float))
	(r-be (coerce beta 'double-float)))
    (declare (type double-float r-al r-be i-al)
	     (type real-matrix r-x i-x r-y i-y))
    (real-double-gemv!-typed r-al A r-x r-be r-y job)
    (real-double-gemv!-typed (- i-al) A i-x 1d0 r-y job)
    ;;
    (real-double-gemv!-typed i-al A r-x r-be i-y job)
    (real-double-gemv!-typed r-al A i-x 1d0 i-y job))
  y)

;
(defmethod gemv! ((alpha number) (A complex-matrix) (x real-matrix)
		  (beta complex) (y complex-matrix) &optional (job :n))
  ;; y <- \beta y
  (scal! beta y)
  ;; y <- y + \alpha . A o x
  (gemv! alpha A x 1d0 y job))

(defmethod gemv! ((alpha cl:real) (A complex-matrix) (x real-matrix)
		  (beta cl:real) (y complex-matrix) &optional (job :n))
  (let ((r-A (mrealpart A))
	(i-A (mimagpart A))
	(r-y (mrealpart y))
	(i-y (mimagpart y))
	(r-al (coerce (realpart alpha) 'double-float))
	(r-be (coerce beta 'double-float)))
    (declare (type double-float r-al r-be)
	     (type real-matrix r-A i-A r-y i-y))
    ;; (mrealpart y) <- \beta * (mrealpart y) + \alpha . A o (mrealpart x)
    (real-double-gemv!-typed r-al r-A x r-be r-y job)
    ;; (mimagpart y) <- \beta * (mimagpart y) + \alpha . A o (mrealpart x)
    (real-double-gemv!-typed r-al i-A x r-be i-y job))
  y)

(defmethod gemv! ((alpha complex) (A complex-matrix) (x real-matrix)
		  (beta cl:real) (y complex-matrix) &optional (job :n))
  (let ((r-A (mrealpart A))
	(i-A (mimagpart A))
	(r-y (mrealpart y))
	(i-y (mimagpart y))
	(r-al (coerce (realpart alpha) 'double-float))
	(i-al (coerce (imagpart alpha) 'double-float))
	(r-be (coerce beta 'double-float)))
    (declare (type double-float r-al r-be i-al)
	     (type real-matrix r-A i-A r-y i-y))
    (real-double-gemv!-typed r-al r-A x r-be r-y job)
    (real-double-gemv!-typed (- i-al) i-A x 1d0 r-y job)
    ;;
    (real-double-gemv!-typed i-al r-A x r-be i-y job)
    (real-double-gemv!-typed r-al i-A x 1d0 i-y job))
  y)

;;;;
(defgeneric gemv (alpha A x beta y &optional job)
  (:documentation
"
  Syntax
  ======
  (GEMV alpha A x beta y [job])

  Purpose
  =======
  Returns the GEneral Matrix Vector operation given by

            alpha * op(A) * x + beta * y

  alpha,beta are scalars,
  A is a matrix, and x,y are vectors.

  op(A) means either A or A'.

     JOB                    Operation
  ---------------------------------------------------
     :N (default)      alpha * A * x + beta * y
     :T                alpha * A'* x + beta * y
"))

(defmethod gemv ((alpha number) (A standard-matrix) (x standard-matrix)
		 (beta number) (y standard-matrix) &optional (job :n))
  (let ((result (scal (if (or (typep alpha 'complex) (typep beta 'complex)
			      (typep A 'complex-matrix) (typep x 'complex-matrix))
			  (complex-coerce beta)
			  beta)
		      y)))
    (declare (type standard-matrix y))
    (gemv! alpha A x 1d0 result job)))